<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>å¨æˆ¿ MVP</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 900px; margin: 40px auto; padding: 0 16px; }
    input, button { font-size: 16px; padding: 10px; }
    input { width: 100%; box-sizing: border-box; margin: 8px 0; }
    button { cursor: pointer; margin-right: 8px; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 16px; margin-top: 16px; }
    .row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    .result { font-size: 18px; font-weight: bold; margin-top: 8px; }
    .hint { color: #666; font-size: 14px; margin-top: 8px; }
    ul { padding-left: 18px; }
    li { margin: 8px 0; line-height: 1.4; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    th, td { border: 1px solid #eee; padding: 8px; text-align: left; }
    .small { font-size: 13px; color: #666; }
    .pill { display: inline-block; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; margin-left: 6px; font-size: 12px; color: #333; }
  </style>
</head>

<body>
  <h1>å¨æˆ¿ MVPï¼ˆ1.å½•å…¥ 2.æ¨è 3.å‡åº“å­˜ï¼‰</h1>

  <!-- 1) å†™å…¥åº“å­˜ -->
  <div class="card">
    <h2>â‘  å½•å…¥å†°ç®±åº“å­˜ </h2>

    <div class="row">
      <div>
        <label>é£Ÿæåç§°</label>
        <input id="invName" placeholder="ä¾‹å¦‚ï¼šé¸¡è›‹" />
      </div>
      <div>
        <label>æ•°é‡ï¼ˆæ•´æ•°ï¼‰</label>
        <input id="invQty" placeholder="ä¾‹å¦‚ï¼š6" />
      </div>
      <div>
        <label>ä¿è´¨æœŸï¼ˆæ—¥æœŸï¼‰</label>
        <input id="invExp" type="date" />
      </div>
    </div>

    <button id="addInvBtn">æ·»åŠ /æ›´æ–°åº“å­˜</button>
    <button id="clearInvBtn">æ¸…ç©ºåº“å­˜</button>
    <span class="small">æç¤ºï¼šåŒåé£Ÿæä¼šåˆå¹¶æ•°é‡ï¼Œå¹¶ç”¨æ›´è¿‘çš„åˆ°æœŸæ—¥ä½œä¸ºè¯¥é£Ÿæåˆ°æœŸæ—¥ã€‚</span>

    <div id="invStatus" class="hint"></div>

    <h3 style="margin-top:14px;">å½“å‰åº“å­˜</h3>
    <table>
      <thead>
        <tr>
          <th>é£Ÿæ</th>
          <th>æ•°é‡</th>
          <th>åˆ°æœŸæ—¥</th>
          <th>å‰©ä½™å¤©æ•°</th>
          <th>æ“ä½œ</th>
        </tr>
      </thead>
      <tbody id="invTableBody"></tbody>
    </table>
  </div>

  <!-- 2) æ¨è -->
  <div class="card">
    <h2>â‘¡ ç”Ÿæˆæ¨èèœ </h2>

    <label for="ingredients">å¯é€‰ï¼šé¢å¤–è¾“å…¥é£Ÿæï¼ˆä¸ç”¨æ ‡ç‚¹ä¹Ÿè¡Œï¼Œç”¨ç©ºæ ¼/é€—å·éƒ½è¡Œï¼‰</label>
    <input id="ingredients" placeholder="ä¾‹å¦‚ï¼šé¸¡è›‹ æ´‹è‘±ï¼ˆå¯ä¸å¡«ï¼Œé»˜è®¤ç”¨åº“å­˜ï¼‰" />

    <button id="btn">ç”Ÿæˆæ¨èèœå“</button>

    <button id="voiceBtn">ğŸ™ï¸ å¼€å§‹è¯­éŸ³å¯¹è¯</button>
    <div class="hint" id="asrStatus">è¯­éŸ³çŠ¶æ€ï¼šæœªå¼€å§‹</div>
    <div class="card" style="margin-top:12px;">
      <div class="small"><b>è¯†åˆ«æ–‡æœ¬</b>ï¼š<span id="asrText">-</span></div>
      <div class="small"><b>AIå¯¹è¯</b>ï¼š</div>
      <div id="chatLog" class="small" style="white-space:pre-wrap;"></div>
    </div>

    <div class="result" id="output"></div>
    <ul id="list"></ul>
    <div class="hint" id="hint"></div>
  </div>

  <script>
    // ========== â€œæ•°æ®åº“â€ï¼šlocalStorage ==========
    const INV_KEY = "kitchen_inventory_v1";

    function loadInventory() {
      try {
        const raw = localStorage.getItem(INV_KEY);
        if (!raw) return {};
        return JSON.parse(raw);
      } catch {
        return {};
      }
    }

    function saveInventory(invObj) {
      localStorage.setItem(INV_KEY, JSON.stringify(invObj));
    }

    function daysLeft(expDateStr) {
      if (!expDateStr) return 9999;
      const today = new Date();
      const exp = new Date(expDateStr + "T00:00:00");
      const diffMs = exp.getTime() - new Date(today.toDateString()).getTime();
      return Math.floor(diffMs / (1000 * 60 * 60 * 24));
    }

    function renderInventoryTable() {
      const inv = loadInventory();
      const body = document.getElementById("invTableBody");
      body.innerHTML = "";

      const names = Object.keys(inv).sort((a, b) => a.localeCompare(b, "zh"));
      if (names.length === 0) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="5" class="small">æš‚æ— åº“å­˜ã€‚è¯·å…ˆå½•å…¥é£Ÿæ/æ•°é‡/ä¿è´¨æœŸã€‚</td>`;
        body.appendChild(tr);
        return;
      }

      names.forEach(name => {
        const item = inv[name];
        const dl = daysLeft(item.expiresAt);
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${name}</td>
          <td>${item.qty}</td>
          <td>${item.expiresAt || "-"}</td>
          <td>${dl === 9999 ? "-" : dl}</td>
          <td><button data-del="${name}">åˆ é™¤</button></td>
        `;
        body.appendChild(tr);
      });

      // delete handlers
      body.querySelectorAll("button[data-del]").forEach(btn => {
        btn.addEventListener("click", () => {
          const name = btn.getAttribute("data-del");
          const inv2 = loadInventory();
          delete inv2[name];
          saveInventory(inv2);
          renderInventoryTable();
        });
      });
    }

    // ========== è¾“å…¥è§£æï¼ˆå…è®¸æ— æ ‡ç‚¹ï¼‰ ==========
    function normalizeInput(text) {
      return text
        .replace(/[0-9]/g, "")
        .replace(/å’Œ|ä¸/g, " ")
        .replace(/[^\u4e00-\u9fa5]/g, " ")
        .split(" ")
        .map(s => s.trim())
        .filter(Boolean);
    }

    // ========== èœè°±è¯»å– ==========
    async function loadRecipes() {
      const res = await fetch("./recipes.json");
      if (!res.ok) throw new Error("æ— æ³•è¯»å– recipes.json");
      return await res.json();
    }

    // ========== æ¨èè¯„åˆ†è§„åˆ™ ==========
    // ä½ çš„åŸåˆ™ï¼š
    // 1) ä¸´è¿‘ä¿è´¨æœŸä¼˜å…ˆ
    // 2) æ•°é‡å¤šä¼˜å…ˆ
    // 3) é£Ÿæå°‘ï¼ˆç®€å•ï¼‰ä¼˜å…ˆ
    //
    // å®ç°æ–¹æ³•ï¼ˆMVPï¼‰ï¼š
    // - å¯¹æ¯é“å€™é€‰èœï¼Œè®¡ç®—ï¼š
    //   earliestExpiryDaysUsedï¼šè¯¥èœä½¿ç”¨åˆ°çš„åº“å­˜é£Ÿæä¸­ï¼Œæœ€å°å‰©ä½™å¤©æ•°ï¼ˆè¶Šå°è¶Šä¼˜å…ˆï¼‰
    //   totalQtyUsed: è¯¥èœä½¿ç”¨åˆ°çš„åº“å­˜é£Ÿææ•°é‡åˆè®¡ï¼ˆè¶Šå¤§è¶Šä¼˜å…ˆï¼‰
    //   recipeIngredientCount: èœçš„ä¸»é£Ÿææ•°ï¼ˆè¶Šå°è¶Šä¼˜å…ˆï¼‰
    //
    // æ’åºï¼šearliestExpiryDaysUsed â†‘, totalQtyUsed â†“, recipeIngredientCount â†‘
    function scoreRecipe(recipe, inv, extraSet) {
      // è¿™é“èœâ€œç”¨åˆ°çš„é£Ÿæâ€= recipe.ingredients
      // å¯ç”¨é£Ÿæé›†åˆ = åº“å­˜æœ‰ qty>0 çš„ + é¢å¤–è¾“å…¥
      const available = new Set(Object.keys(inv).filter(k => inv[k].qty > 0));
      for (const x of extraSet) available.add(x);

      const missing = recipe.ingredients.filter(ing => !available.has(ing));
      const missingCount = missing.length;

      // ç”¨åˆ°çš„åº“å­˜é£Ÿæï¼ˆä»…åº“å­˜éƒ¨åˆ†ï¼Œç”¨äºç®—ä¿è´¨æœŸ/æ•°é‡ï¼‰
      const usedFromInv = recipe.ingredients.filter(ing => inv[ing] && inv[ing].qty > 0);

      let earliest = 9999;
      let qtySum = 0;
      usedFromInv.forEach(ing => {
        earliest = Math.min(earliest, daysLeft(inv[ing].expiresAt));
        qtySum += Number(inv[ing].qty || 0);
      });

      // å¦‚æœå®Œå…¨æ²¡ç”¨åˆ°åº“å­˜ï¼Œåªç”¨é¢å¤–è¾“å…¥ï¼ˆä¾‹å¦‚ä½ æ‰‹åŠ¨è¾“å…¥äº†æŸé£Ÿæä½†åº“å­˜æ²¡å½•ï¼‰ï¼Œ
      // é‚£ä¹ˆ earliest/qtySum è®¾ä¸ºä¸ä¼˜å…ˆï¼ˆMVPç­–ç•¥ï¼‰
      if (usedFromInv.length === 0) {
        earliest = 9999;
        qtySum = 0;
      }

      return {
        missing,
        missingCount,
        usedFromInv,
        earliestExpiryDaysUsed: earliest,
        totalQtyUsed: qtySum,
        recipeIngredientCount: recipe.ingredients.length
      };
    }

    // ========== æ‰£åº“å­˜ï¼ˆç‚¹å‡»èœå“åï¼‰ ==========
    function consumeRecipe(recipe) {
      const inv = loadInventory();

      // æ‰¾å‡ºéœ€è¦æ‰£å‡çš„â€œåº“å­˜é£Ÿæâ€ï¼ˆåªå¯¹åº“å­˜é‡Œå­˜åœ¨çš„é£Ÿææ‰£ï¼‰
      const need = recipe.ingredients.filter(ing => inv[ing] && inv[ing].qty > 0);
      if (need.length === 0) {
        alert("è¿™é“èœæ²¡æœ‰å¯æ‰£å‡çš„åº“å­˜é£Ÿæï¼ˆå¯èƒ½ä½ æ²¡å½•å…¥åº“å­˜ï¼‰ã€‚");
        return;
      }

      // ç®€åŒ–ï¼šé»˜è®¤æ¯ç§é£Ÿææ¶ˆè€— 1 å•ä½ï¼›ç”¨æˆ·å¯é€ä¸ªç¡®è®¤/ä¿®æ”¹
      const consumePlan = {};
      for (const ing of need) {
        const max = inv[ing].qty;
        const input = prompt(`ã€${recipe.name}ã€‘\nè¯·è¾“å…¥è¦æ¶ˆè€—çš„ã€${ing}ã€‘æ•°é‡ï¼ˆåº“å­˜å‰©ä½™ ${max}ï¼‰ï¼š`, "1");
        if (input === null) return; // ç”¨æˆ·å–æ¶ˆ
        const n = parseInt(input, 10);
        if (!Number.isFinite(n) || n <= 0) {
          alert("æ•°é‡å¿…é¡»æ˜¯æ­£æ•´æ•°ã€‚å·²å–æ¶ˆæ‰£å‡ã€‚");
          return;
        }
        if (n > max) {
          alert(`ã€${ing}ã€‘æ¶ˆè€—æ•°é‡ä¸èƒ½è¶…è¿‡åº“å­˜ï¼ˆ${max}ï¼‰ã€‚å·²å–æ¶ˆæ‰£å‡ã€‚`);
          return;
        }
        consumePlan[ing] = n;
      }

      // æ‰£å‡
      for (const ing of Object.keys(consumePlan)) {
        inv[ing].qty -= consumePlan[ing];
        if (inv[ing].qty < 0) inv[ing].qty = 0;
      }
      saveInventory(inv);

      renderInventoryTable();

      // æ˜¾ç¤ºå‰©ä½™
      const lines = Object.keys(consumePlan).map(ing => `- ${ing}ï¼šæ¶ˆè€— ${consumePlan[ing]}ï¼Œå‰©ä½™ ${inv[ing].qty}`);
      alert(`æ‰£å‡å®Œæˆï¼š\n${lines.join("\n")}`);
    }

    // ========== äº‹ä»¶ï¼šæ·»åŠ åº“å­˜ ==========
    document.getElementById("addInvBtn").addEventListener("click", () => {
      const name = document.getElementById("invName").value.trim();
      const qtyStr = document.getElementById("invQty").value.trim();
      const exp = document.getElementById("invExp").value;

      const status = document.getElementById("invStatus");
      status.textContent = "";

      if (!name) { status.textContent = "è¯·è¾“å…¥é£Ÿæåç§°ã€‚"; return; }
      const qty = parseInt(qtyStr, 10);
      if (!Number.isFinite(qty) || qty <= 0) { status.textContent = "æ•°é‡å¿…é¡»æ˜¯æ­£æ•´æ•°ã€‚"; return; }

      const inv = loadInventory();

      if (!inv[name]) {
        inv[name] = { qty, expiresAt: exp || "" };
      } else {
        // åˆå¹¶æ•°é‡
        inv[name].qty = Number(inv[name].qty || 0) + qty;

        // åˆ°æœŸæ—¥å–æ›´è¿‘çš„ï¼ˆå¦‚æœä¸¤è€…éƒ½æœ‰ï¼‰
        if (exp && inv[name].expiresAt) {
          const d1 = daysLeft(inv[name].expiresAt);
          const d2 = daysLeft(exp);
          inv[name].expiresAt = (d2 < d1) ? exp : inv[name].expiresAt;
        } else if (exp && !inv[name].expiresAt) {
          inv[name].expiresAt = exp;
        }
      }

      saveInventory(inv);
      renderInventoryTable();

      status.textContent = `å·²å†™å…¥ï¼š${name} +${qty}ï¼ˆåˆ°æœŸï¼š${exp || "æœªå¡«"}ï¼‰`;
      document.getElementById("invName").value = "";
      document.getElementById("invQty").value = "";
      document.getElementById("invExp").value = "";
    });

    document.getElementById("clearInvBtn").addEventListener("click", () => {
      if (!confirm("ç¡®å®šè¦æ¸…ç©ºåº“å­˜å—ï¼Ÿ")) return;
      localStorage.removeItem(INV_KEY);
      renderInventoryTable();
      document.getElementById("invStatus").textContent = "åº“å­˜å·²æ¸…ç©ºã€‚";
    });

    // ========== äº‹ä»¶ï¼šç”Ÿæˆæ¨è ==========
    document.getElementById("btn").addEventListener("click", async () => {
      const output = document.getElementById("output");
      const hint = document.getElementById("hint");
      const list = document.getElementById("list");
      output.textContent = "å¤„ç†ä¸­...";
      hint.textContent = "";
      list.innerHTML = "";

      const inv = loadInventory();
      const invSet = new Set(Object.keys(inv).filter(k => inv[k].qty > 0));

      const inputText = document.getElementById("ingredients").value;
      const extra = new Set(normalizeInput(inputText));

      // å¯ç”¨é£Ÿæä¸ºç©ºåˆ™æç¤º
      if (invSet.size === 0 && extra.size === 0) {
        output.textContent = "";
        hint.textContent = "è¯·å…ˆå½•å…¥åº“å­˜ï¼Œæˆ–åœ¨ä¸Šæ–¹è¾“å…¥é¢å¤–é£Ÿæã€‚";
        return;
      }

      try {
        const recipes = await loadRecipes();

        // è§„åˆ™ï¼šå…è®¸ç¼º 1 ä¸ªä¸»é£Ÿæä¹Ÿæ¨èï¼ˆæ²¿ç”¨ä½ ç°åœ¨çš„ç­–ç•¥ï¼‰ï¼Œä½†è¿™é‡Œæ”¹æˆâ€œåŸºäºåº“å­˜/é¢å¤–è¾“å…¥â€
        const candidates = recipes
          .map(r => {
            const s = scoreRecipe(r, inv, extra);
            // å¿…é¡»è‡³å°‘ç”¨åˆ°ä¸€ä¸ªâ€œå¯ç”¨é£Ÿæâ€ï¼ˆå¦åˆ™æ˜¯æ— å…³èœï¼‰
            const available = new Set([...invSet, ...extra]);
            const usedFromAvailable = r.ingredients.filter(ing => available.has(ing));
            return { recipe: r, ...s, usedFromAvailable, usedCount: usedFromAvailable.length };
          })
          .filter(x => x.usedCount >= 1)
          .filter(x => x.missingCount <= 1);

        if (candidates.length === 0) {
          output.textContent = "æœªæ‰¾åˆ°å¯æ¨èèœå“";
          hint.textContent = "è§„åˆ™ï¼šåªæ¨èç¼º 0 æˆ–ç¼º 1 ä¸ªä¸»é£Ÿæï¼Œä¸”å¿…é¡»ç”¨åˆ°ä½ ç°æœ‰çš„é£Ÿæã€‚";
          return;
        }

        // æŒ‰ä½ çš„ä¸‰æ¡åŸåˆ™æ’åº
        candidates.sort((a, b) => {
          // å…ˆï¼šç¼ºå¾—å°‘ï¼ˆç¼º0ä¼˜å…ˆï¼‰ï¼Œä¿è¯â€œèƒ½åšâ€ä¼˜å…ˆ
          if (a.missingCount !== b.missingCount) return a.missingCount - b.missingCount;
          // 1) ä¸´è¿‘ä¿è´¨æœŸä¼˜å…ˆï¼ˆearliest è¶Šå°è¶Šé å‰ï¼‰
          if (a.earliestExpiryDaysUsed !== b.earliestExpiryDaysUsed) return a.earliestExpiryDaysUsed - b.earliestExpiryDaysUsed;
          // 2) æ•°é‡å¤šä¼˜å…ˆï¼ˆqtySum è¶Šå¤§è¶Šé å‰ï¼‰
          if (a.totalQtyUsed !== b.totalQtyUsed) return b.totalQtyUsed - a.totalQtyUsed;
          // 3) é£Ÿæå°‘ä¼˜å…ˆï¼ˆè¶Šç®€å•è¶Šé å‰ï¼‰
          return a.recipeIngredientCount - b.recipeIngredientCount;
        });

        const top5 = candidates.slice(0, 5);
        output.textContent = "æ¨èèœå“ï¼ˆç‚¹å‡»å¯æ‰£åº“å­˜ï¼Œæœ€å¤š 5 ä¸ªï¼‰ï¼š";

        top5.forEach((item, index) => {
          const li = document.createElement("li");

          const r = item.recipe;
          const missingText = item.missingCount === 0 ? "âœ… é£Ÿæé½å…¨" : `âš ï¸ ç¼ºï¼š${item.missing[0]}`;
          const expiryText = (item.earliestExpiryDaysUsed === 9999) ? "åˆ°æœŸï¼š-" : `æœ€æ—©åˆ°æœŸï¼š${item.earliestExpiryDaysUsed} å¤©`;
          const qtyText = `åº“å­˜æ•°é‡ä¼˜å…ˆå€¼ï¼š${item.totalQtyUsed}`;
          const simpleText = `ä¸»é£Ÿææ•°ï¼š${r.ingredients.length}`;

          // è¾“å‡º name, ingredients, seasonings
          li.innerHTML = `
            <div>
              <strong>${index + 1}. ${r.name}</strong>
              <span class="pill">${missingText}</span>
              <span class="pill">${expiryText}</span>
              <span class="pill">${qtyText}</span>
              <span class="pill">${simpleText}</span>
            </div>
            <div class="small"><b>Ingredients</b>ï¼š${r.ingredients.join("ã€")}</div>
            <div class="small"><b>Seasonings</b>ï¼š${(r.seasonings || []).join("ã€")}</div>
          `;

          // ç‚¹å‡»æ‰£åº“å­˜ï¼ˆä»…å½“é£Ÿæé½å…¨æ—¶æ›´åˆç†ï¼›ä½ ä¹Ÿå¯ä»¥å…è®¸ç¼º1çš„å…ˆæç¤ºï¼‰
          li.style.cursor = "pointer";
          li.addEventListener("click", () => {
            if (item.missingCount > 0) {
              alert(`è¿™é“èœè¿˜ç¼ºï¼š${item.missing[0]}ã€‚\nå»ºè®®å…ˆè¡¥é½å†æ‰£åº“å­˜ã€‚`);
              return;
            }
            consumeRecipe(r);
          });

          list.appendChild(li);
        });

        hint.textContent = "æ’åºåŸåˆ™ï¼šå…ˆèƒ½åšï¼ˆç¼º0ä¼˜å…ˆï¼‰ï¼Œå†æŒ‰æœ€æ—©åˆ°æœŸâ†‘ã€æ•°é‡ä¼˜å…ˆâ†“ã€ä¸»é£Ÿææ•°â†‘ã€‚ç‚¹å‡»èœåå¯æ‰£åº“å­˜å¹¶æ˜¾ç¤ºå‰©ä½™ã€‚";
      } catch (e) {
        output.textContent = "å‡ºé”™äº†";
        hint.textContent = e.message;
      }
    });

    // åˆå§‹æ¸²æŸ“åº“å­˜
    renderInventoryTable();
    // ===================== è¯­éŸ³ï¼šASR + TTS =====================
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    
    let recognition = null;
    let listening = false;
    
    function speakCN(text) {
      // æ¸©æŸ”ã€çŸ­å¥
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "zh-CN";
      u.rate = 1.0;
      u.pitch = 1.05;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    }
    
    function logChat(role, text) {
      const el = document.getElementById("chatLog");
      el.textContent += `${role}ï¼š${text}\n`;
    }
    
    function setASRStatus(text) {
      document.getElementById("asrStatus").textContent = `è¯­éŸ³çŠ¶æ€ï¼š${text}`;
    }
    
    function setASRText(text) {
      document.getElementById("asrText").textContent = text || "-";
    }
    
    // ===================== å¯¹è¯çŠ¶æ€æœºï¼ˆMVPï¼‰ =====================
    const AGENT_KEY = "kitchen_agent_state_v1";
    const PDCA_KEY = "kitchen_pdca_v1";
    
    const State = {
      IDLE: "IDLE",
      ASK_INV_NAME: "ASK_INV_NAME",
      ASK_INV_QTY: "ASK_INV_QTY",
      ASK_INV_EXP: "ASK_INV_EXP",
      ASK_MORE_INV: "ASK_MORE_INV",
      RECOMMENDED: "RECOMMENDED",
      ASK_ADD_MORE: "ASK_ADD_MORE",
      SELECT_DISH: "SELECT_DISH",
      CONFIRM_DEDUCT: "CONFIRM_DEDUCT",
      DEDUCT_QTY_LOOP: "DEDUCT_QTY_LOOP",
      PDCA: "PDCA"
    };
    
    let agent = {
      state: State.IDLE,
      pendingInv: { name: "", qty: 0, exp: "" },
      selectedRecipe: null,
      deductQueue: [],
      deductPlan: {}
    };
    
    function resetAgent() {
      agent = {
        state: State.IDLE,
        pendingInv: { name: "", qty: 0, exp: "" },
        selectedRecipe: null,
        deductQueue: [],
        deductPlan: {}
      };
    }
    
    // ç®€å•æ„å›¾è¯†åˆ«ï¼ˆå…ˆè§„åˆ™ï¼Œåç»­å¯æ¢ LLMï¼‰
    function detectIntent(text) {
      const t = text.replace(/\s+/g, "");
      if (/åšé¥­|åšèœ|ç‚’èœ|åƒä»€ä¹ˆ|æ¨è|èœå•|æƒ³åƒ/.test(t)) return "START_COOK";
      if (/æ›´å¤šé£Ÿæ|æ–°é£Ÿæ|å†åŠ |æˆ‘è¿˜æœ‰|æˆ‘ä¹°äº†/.test(t)) return "ADD_ING";
      if (/æ²¡æœ‰|å°±è¿™äº›|ä¸ç”¨äº†|ç»“æŸ/.test(t)) return "NO_MORE";
      if (/ç¬¬([ä¸€äºŒä¸‰å››äº”])ä¸ª|ç¬¬(\d+)ä¸ª|æˆ‘é€‰|å°±åš|åš(.+)/.test(t)) return "CHOOSE_DISH";
      if (/å¯ä»¥|è¡Œ|å¥½|ok|OK|å¥½çš„|åŒæ„/.test(t)) return "YES";
      if (/ä¸|ä¸è¦|ç®—äº†/.test(t)) return "NO";
      return "UNKNOWN";
    }
    
    // è§£æâ€œç¬¬å‡ ä¸ªâ€
    function parseIndex(text) {
      const t = text.replace(/\s+/g, "");
      const m1 = t.match(/ç¬¬(\d+)ä¸ª/);
      if (m1) return parseInt(m1[1], 10) - 1;
    
      const map = { ä¸€:0, äºŒ:1, ä¸‰:2, å››:3, äº”:4 };
      const m2 = t.match(/ç¬¬([ä¸€äºŒä¸‰å››äº”])ä¸ª/);
      if (m2) return map[m2[1]];
    
      return null;
    }
    
    // è§£ææ•°é‡ï¼šæå–æ•°å­—ï¼ˆâ€œå…­â€æš‚ä¸åšï¼ŒMVPå…ˆè¦ç”¨æˆ·è¯´æ•°å­—ï¼‰
    function parseQty(text) {
      const m = text.match(/(\d+)/);
      if (!m) return null;
      return parseInt(m[1], 10);
    }
    
    // è§£ææ—¥æœŸï¼šæ”¯æŒ 2026-01-10 / 1æœˆ10æ—¥ / 01-10
    function parseDate(text) {
      const t = text.replace(/\s+/g, "");
      // YYYY-MM-DD
      let m = t.match(/(20\d{2})[-\/](\d{1,2})[-\/](\d{1,2})/);
      if (m) return `${m[1]}-${String(m[2]).padStart(2,"0")}-${String(m[3]).padStart(2,"0")}`;
    
      // MM-DD
      m = t.match(/(\d{1,2})[-\/](\d{1,2})/);
      if (m) {
        const y = new Date().getFullYear();
        return `${y}-${String(m[1]).padStart(2,"0")}-${String(m[2]).padStart(2,"0")}`;
      }
    
      // 1æœˆ10æ—¥ / 1æœˆ10å·
      m = t.match(/(\d{1,2})æœˆ(\d{1,2})(æ—¥|å·)?/);
      if (m) {
        const y = new Date().getFullYear();
        return `${y}-${String(m[1]).padStart(2,"0")}-${String(m[2]).padStart(2,"0")}`;
      }
    
      return null;
    }
    
    // ===================== å…³é”®ï¼šæŠŠé¡µé¢æ¨èç»“æœä¿å­˜ä¸‹æ¥ï¼ˆä¾›â€œé€‰ç¬¬å‡ ä¸ªâ€ç”¨ï¼‰ =====================
    let lastTop5 = []; // ä¿å­˜æœ€è¿‘ä¸€æ¬¡æ¨èçš„ top5 recipesï¼ˆé¡ºåºå¯¹åº”1-5ï¼‰
    
    async function recommendTop5(extraText = "") {
      // ç›´æ¥å¤ç”¨ä½ å½“å‰æŒ‰é’®çš„é€»è¾‘ï¼šè¿™é‡Œå¤åˆ¶â€œç”Ÿæˆæ¨èâ€çš„æ ¸å¿ƒï¼Œä½†ä¸ç‚¹æŒ‰é’®
      const output = document.getElementById("output");
      const hint = document.getElementById("hint");
      const list = document.getElementById("list");
    
      output.textContent = "å¤„ç†ä¸­...";
      hint.textContent = "";
      list.innerHTML = "";
    
      const inv = loadInventory();
      const invSet = new Set(Object.keys(inv).filter(k => inv[k].qty > 0));
      const extra = new Set(normalizeInput(extraText));
    
      if (invSet.size === 0 && extra.size === 0) {
        output.textContent = "";
        hint.textContent = "è¯·å…ˆå½•å…¥åº“å­˜ï¼Œæˆ–è¾“å…¥é¢å¤–é£Ÿæã€‚";
        lastTop5 = [];
        return [];
      }
    
      const recipes = await loadRecipes();
    
      const candidates = recipes
        .map(r => {
          const s = scoreRecipe(r, inv, extra);
          const available = new Set([...invSet, ...extra]);
          const usedFromAvailable = r.ingredients.filter(ing => available.has(ing));
          return { recipe: r, ...s, usedFromAvailable, usedCount: usedFromAvailable.length };
        })
        .filter(x => x.usedCount >= 1)
        .filter(x => x.missingCount <= 1);
    
      if (candidates.length === 0) {
        output.textContent = "æœªæ‰¾åˆ°å¯æ¨èèœå“";
        hint.textContent = "è§„åˆ™ï¼šåªæ¨èç¼º 0 æˆ–ç¼º 1 ä¸ªä¸»é£Ÿæï¼Œä¸”å¿…é¡»ç”¨åˆ°ä½ ç°æœ‰çš„é£Ÿæã€‚";
        lastTop5 = [];
        return [];
      }
    
      candidates.sort((a, b) => {
        if (a.missingCount !== b.missingCount) return a.missingCount - b.missingCount;
        if (a.earliestExpiryDaysUsed !== b.earliestExpiryDaysUsed) return a.earliestExpiryDaysUsed - b.earliestExpiryDaysUsed;
        if (a.totalQtyUsed !== b.totalQtyUsed) return b.totalQtyUsed - a.totalQtyUsed;
        return a.recipeIngredientCount - b.recipeIngredientCount;
      });
    
      const top5 = candidates.slice(0, 5);
      lastTop5 = top5.map(x => x.recipe);
    
      output.textContent = "æ¨èèœå“ï¼ˆç‚¹å‡»å¯æ‰£åº“å­˜ï¼Œæœ€å¤š 5 ä¸ªï¼‰ï¼š";
    
      top5.forEach((item, index) => {
        const li = document.createElement("li");
        const r = item.recipe;
        const missingText = item.missingCount === 0 ? "âœ… é£Ÿæé½å…¨" : `âš ï¸ ç¼ºï¼š${item.missing[0]}`;
        li.innerHTML = `
          <div>
            <strong>${index + 1}. ${r.name}</strong>
            <span class="pill">${missingText}</span>
          </div>
          <div class="small"><b>Ingredients</b>ï¼š${r.ingredients.join("ã€")}</div>
          <div class="small"><b>Seasonings</b>ï¼š${(r.seasonings || []).join("ã€")}</div>
        `;
        li.style.cursor = "pointer";
        li.addEventListener("click", () => {
          // ç›´æ¥èµ°ä½ ç°æœ‰çš„ç‚¹å‡»æ‰£åº“å­˜ï¼ˆä½†è¯­éŸ³æµç¨‹é‡Œæˆ‘ä»¬ä¼šåšäºŒæ¬¡ç¡®è®¤ï¼‰
          consumeRecipe(r);
        });
        list.appendChild(li);
      });
    
      hint.textContent = "æ’åºï¼šç¼º0ä¼˜å…ˆï¼Œå…¶æ¬¡æœ€æ—©åˆ°æœŸâ†‘ã€æ•°é‡ä¼˜å…ˆâ†“ã€é£Ÿææ•°â†‘ã€‚";
      return lastTop5;
    }
    
    // ===================== å¯¹è¯å¤„ç†å…¥å£ =====================
    async function handleUserText(text) {
      if (!text) return;
      logChat("äºº", text);
    
      const inv = loadInventory();
      const hasInventory = Object.keys(inv).some(k => inv[k].qty > 0);
    
      const intent = detectIntent(text);
    
      // IDLE: ç”¨æˆ·è¯´â€œåšé¥­/æ¨èâ€
      if (agent.state === State.IDLE) {
        if (intent === "START_COOK") {
          const greet = "æˆ‘æ˜¯AIå¨æˆ¿åŠ©æ‰‹ï¼Œæœ‰ä»€ä¹ˆèƒ½å¸®æ‚¨ï¼Ÿ";
          logChat("AI", greet); speakCN(greet);
    
          if (!hasInventory) {
            agent.state = State.ASK_INV_NAME;
            const q = "æˆ‘å…ˆå¸®æ‚¨è®°å½•å†°ç®±åº“å­˜ã€‚å†°ç®±é‡Œæœ‰ä»€ä¹ˆé£Ÿæï¼Ÿè¯·è¯´ä¸€ä¸ªé£Ÿæåç§°ã€‚";
            logChat("AI", q); speakCN(q);
          } else {
            agent.state = State.RECOMMENDED;
            const q = "å¥½çš„ã€‚æˆ‘å°†åŸºäºæ‚¨ç°æœ‰åº“å­˜ï¼Œç»™æ‚¨æ¨è5ä¸ªèœå“ã€‚";
            logChat("AI", q); speakCN(q);
            await recommendTop5("");
            const q2 = "å¦‚æœæ‚¨æƒ³æ–°å¢é£Ÿæï¼Œè¯´â€œæ›´å¤šé£Ÿæâ€ã€‚å¦‚æœè¦é€‰æ‹©èœå“ï¼Œè¯´â€œæˆ‘é€‰ç¬¬å‡ ä¸ªâ€ã€‚";
            logChat("AI", q2); speakCN(q2);
          }
          return;
        }
    
        const tip = "æ‚¨å¯ä»¥è¯´ï¼šåšé¥­ã€æ¨èèœã€ä»Šå¤©åƒä»€ä¹ˆã€‚";
        logChat("AI", tip); speakCN(tip);
        return;
      }
    
      // å½•å…¥åº“å­˜ä¸‰é—®
      if (agent.state === State.ASK_INV_NAME) {
        if (intent === "NO_MORE") {
          const t = "å¥½çš„ã€‚é‚£æˆ‘å…ˆä¸ºæ‚¨æ¨èèœå“ã€‚";
          logChat("AI", t); speakCN(t);
          agent.state = State.RECOMMENDED;
          await recommendTop5("");
          return;
        }
        agent.pendingInv.name = text.trim();
        agent.state = State.ASK_INV_QTY;
        const q = `${agent.pendingInv.name} æœ‰å¤šå°‘ï¼Ÿè¯·è¯´æ•°å­—ã€‚`;
        logChat("AI", q); speakCN(q);
        return;
      }
    
      if (agent.state === State.ASK_INV_QTY) {
        const qty = parseQty(text);
        if (!qty || qty <= 0) {
          const q = "æˆ‘æ²¡å¬æ¸…æ•°é‡ã€‚è¯·åªè¯´æ•°å­—ï¼Œä¾‹å¦‚ 6ã€‚";
          logChat("AI", q); speakCN(q);
          return;
        }
        agent.pendingInv.qty = qty;
        agent.state = State.ASK_INV_EXP;
        const q = "ä¿è´¨æœŸåˆ°å“ªå¤©ï¼Ÿè¯·è¯´æ—¥æœŸï¼Œä¾‹å¦‚ 2026-01-10 æˆ– 1æœˆ10æ—¥ã€‚";
        logChat("AI", q); speakCN(q);
        return;
      }
    
      if (agent.state === State.ASK_INV_EXP) {
        const d = parseDate(text);
        if (!d) {
          const q = "æˆ‘æ²¡å¬æ¸…æ—¥æœŸã€‚è¯·è¯´ä¾‹å¦‚ 2026-01-10 æˆ– 1æœˆ10æ—¥ã€‚";
          logChat("AI", q); speakCN(q);
          return;
        }
        agent.pendingInv.exp = d;
    
        // å†™å…¥åº“å­˜ï¼ˆå¤ç”¨ä½ ç°æœ‰é€»è¾‘ï¼šåŒååˆå¹¶ã€åˆ°æœŸå–æ›´è¿‘ï¼‰
        const inv2 = loadInventory();
        const name = agent.pendingInv.name;
        const qty = agent.pendingInv.qty;
        const exp = agent.pendingInv.exp;
    
        if (!inv2[name]) inv2[name] = { qty, expiresAt: exp };
        else {
          inv2[name].qty = Number(inv2[name].qty || 0) + qty;
          if (exp && inv2[name].expiresAt) {
            inv2[name].expiresAt = (daysLeft(exp) < daysLeft(inv2[name].expiresAt)) ? exp : inv2[name].expiresAt;
          } else if (exp && !inv2[name].expiresAt) inv2[name].expiresAt = exp;
        }
        saveInventory(inv2);
        renderInventoryTable();
    
        const ok = `å·²è®°å½•ï¼š${name} æ•°é‡ ${qty}ï¼Œåˆ°æœŸ ${exp}ã€‚è¿˜æœ‰å…¶ä»–é£Ÿæå—ï¼Ÿå¦‚æœæ²¡æœ‰è¯·è¯´â€œæ²¡æœ‰â€ã€‚`;
        logChat("AI", ok); speakCN(ok);
        agent.state = State.ASK_INV_NAME;
        agent.pendingInv = { name:"", qty:0, exp:"" };
        return;
      }
    
      // æ¨èåï¼šæ–°å¢é£Ÿæ or é€‰æ‹©èœå“
      if (agent.state === State.RECOMMENDED) {
        if (intent === "ADD_ING") {
          agent.state = State.ASK_INV_NAME;
          const q = "å¥½çš„ï¼Œè¯·è¯´è¦æ–°å¢çš„é£Ÿæåç§°ã€‚";
          logChat("AI", q); speakCN(q);
          return;
        }
    
        if (intent === "CHOOSE_DISH") {
          // è§£æ â€œç¬¬å‡ ä¸ªâ€ æˆ– â€œåšxxxâ€
          let idx = parseIndex(text);
          let chosen = null;
    
          if (idx !== null && lastTop5[idx]) chosen = lastTop5[idx];
    
          // å…œåº•ï¼šæŒ‰èœååŒ¹é…ï¼ˆâ€œå°±åšxxâ€ï¼‰
          if (!chosen) {
            const t = text.replace(/\s+/g, "");
            chosen = lastTop5.find(r => t.includes(r.name.replace(/\s+/g,"")));
          }
    
          if (!chosen) {
            const q = "æˆ‘æ²¡å¬æ¸…æ‚¨é€‰çš„æ˜¯ç¬¬å‡ ä¸ªã€‚è¯·è¯´ï¼šæˆ‘é€‰ç¬¬1ä¸ª/ç¬¬2ä¸ªã€‚";
            logChat("AI", q); speakCN(q);
            return;
          }
    
          agent.selectedRecipe = chosen;
          agent.state = State.CONFIRM_DEDUCT;
    
          const q = `å¥½çš„ï¼Œæ‚¨é€‰æ‹©äº†ï¼š${chosen.name}ã€‚æˆ‘å¯ä»¥ä¸ºæ‚¨åˆ é™¤ï¼ˆæ‰£å‡ï¼‰å†°ç®±é‡Œç›¸åº”é£Ÿææ•°é‡å—ï¼Ÿ`;
          logChat("AI", q); speakCN(q);
          return;
        }
    
        const q = "æ‚¨å¯ä»¥è¯´ï¼šæ›´å¤šé£Ÿæï¼Œæˆ– æˆ‘é€‰ç¬¬å‡ ä¸ªã€‚";
        logChat("AI", q); speakCN(q);
        return;
      }
    
      // äºŒæ¬¡ç¡®è®¤æ‰£åº“å­˜
      if (agent.state === State.CONFIRM_DEDUCT) {
        if (intent === "YES") {
          const r = agent.selectedRecipe;
          const inv3 = loadInventory();
          const need = r.ingredients.filter(ing => inv3[ing] && inv3[ing].qty > 0);
    
          if (need.length === 0) {
            const q = "è¿™é“èœåœ¨åº“å­˜é‡Œæ²¡æœ‰å¯æ‰£å‡çš„é£Ÿæï¼ˆå¯èƒ½æ²¡å½•å…¥ï¼‰ã€‚æˆ‘å…ˆä¸æ‰£å‡ã€‚";
            logChat("AI", q); speakCN(q);
            agent.state = State.PDCA;
            const p = "ä¸ºäº†æ›´å¥½å¸®åŠ©æ‚¨ï¼Œä»Šå¤©æ¨èæ˜¯å¦ç¬¦åˆå£å‘³ï¼Ÿæ‚¨æ›´åå¥½æ¸…æ·¡/ä¸‹é¥­/å¿«æ‰‹å“ªç§ï¼Ÿ";
            logChat("AI", p); speakCN(p);
            return;
          }
    
          agent.deductQueue = need.slice();
          agent.deductPlan = {};
          agent.state = State.DEDUCT_QTY_LOOP;
    
          const ing = agent.deductQueue[0];
          const max = inv3[ing].qty;
          const q = `è¯·è¯´è¦æ¶ˆè€—çš„ ${ing} æ•°é‡ã€‚åº“å­˜å‰©ä½™ ${max}ã€‚ä¾‹å¦‚è¯´ 1ã€‚`;
          logChat("AI", q); speakCN(q);
          return;
        }
    
        if (intent === "NO") {
          const q = "å¥½çš„ï¼Œæˆ‘ä¸æ‰£å‡åº“å­˜ã€‚";
          logChat("AI", q); speakCN(q);
          agent.state = State.PDCA;
          const p = "ä¸ºäº†æ›´å¥½å¸®åŠ©æ‚¨ï¼Œä»Šå¤©æ¨èæ˜¯å¦ç¬¦åˆå£å‘³ï¼Ÿæ‚¨æ›´åå¥½æ¸…æ·¡/ä¸‹é¥­/å¿«æ‰‹å“ªç§ï¼Ÿ";
          logChat("AI", p); speakCN(p);
          return;
        }
    
        const q = "è¯·å›ç­”ï¼šå¯ä»¥ æˆ– ä¸è¦ã€‚";
        logChat("AI", q); speakCN(q);
        return;
      }
    
      // æ‰£åº“å­˜ï¼šé€ä¸ªé£Ÿæè¯¢é—®æ•°é‡
      if (agent.state === State.DEDUCT_QTY_LOOP) {
        const r = agent.selectedRecipe;
        const inv4 = loadInventory();
    
        const ing = agent.deductQueue[0];
        const max = inv4[ing].qty;
        const qty = parseQty(text);
    
        if (!qty || qty <= 0 || qty > max) {
          const q = `æ•°é‡ä¸åˆæ³•ã€‚è¯·è¯´ 1 åˆ° ${max} ä¹‹é—´çš„æ•°å­—ã€‚`;
          logChat("AI", q); speakCN(q);
          return;
        }
    
        agent.deductPlan[ing] = qty;
        agent.deductQueue.shift();
    
        if (agent.deductQueue.length > 0) {
          const next = agent.deductQueue[0];
          const max2 = inv4[next].qty;
          const q = `è¯·è¯´è¦æ¶ˆè€—çš„ ${next} æ•°é‡ã€‚åº“å­˜å‰©ä½™ ${max2}ã€‚`;
          logChat("AI", q); speakCN(q);
          return;
        }
    
        // æ‰§è¡Œæ‰£å‡
        for (const k of Object.keys(agent.deductPlan)) {
          inv4[k].qty -= agent.deductPlan[k];
          if (inv4[k].qty < 0) inv4[k].qty = 0;
        }
        saveInventory(inv4);
        renderInventoryTable();
    
        const remainLines = Object.keys(agent.deductPlan)
          .map(k => `${k} ç°åœ¨å‰©ä½™ ${inv4[k].qty}`)
          .join("ï¼Œ");
    
        const done = `å·²æ‰£å‡å®Œæˆã€‚${remainLines}ã€‚`;
        logChat("AI", done); speakCN(done);
    
        // è¿›å…¥ PDCA
        agent.state = State.PDCA;
        const p = "ä¸ºäº†æ›´å¥½å¸®åŠ©æ‚¨ï¼Œä»Šå¤©æ¨èæ˜¯å¦ç¬¦åˆå£å‘³ï¼Ÿæ‚¨æ›´åå¥½æ¸…æ·¡/ä¸‹é¥­/å¿«æ‰‹å“ªç§ï¼Ÿ";
        logChat("AI", p); speakCN(p);
        return;
      }
    
      // PDCAï¼šæ”¶é›†ä¸€å¥åå¥½å¹¶å­˜å‚¨
      if (agent.state === State.PDCA) {
        const pdca = { time: new Date().toISOString(), feedback: text };
        localStorage.setItem(PDCA_KEY, JSON.stringify(pdca));
    
        const q = "æ”¶åˆ°ã€‚æˆ‘ä¼šè®°ä½æ‚¨çš„åå¥½ï¼Œä¸‹æ¬¡æ¨èä¼šæ›´è´´åˆã€‚éœ€è¦æˆ‘ç»§ç»­æ¨èèœå—ï¼Ÿ";
        logChat("AI", q); speakCN(q);
    
        agent.state = State.RECOMMENDED; // å›åˆ°æ¨èæ€
        return;
      }
    }
    
    // ===================== ç»‘å®šè¯­éŸ³æŒ‰é’® =====================
    document.getElementById("voiceBtn").addEventListener("click", () => {
      if (!SpeechRecognition) {
        alert("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«ã€‚è¯·ä½¿ç”¨ Chrome/Edgeã€‚");
        return;
      }
    
      if (!recognition) {
        recognition = new SpeechRecognition();
        recognition.lang = "zh-CN";
        recognition.interimResults = false;
        recognition.continuous = true;
    
        recognition.onresult = async (event) => {
          const last = event.results[event.results.length - 1];
          const text = last[0].transcript || "";
          setASRText(text);
          await handleUserText(text);
        };
    
        recognition.onerror = (e) => {
          setASRStatus("å‡ºé”™ï¼š" + e.error);
          logChat("ç³»ç»Ÿ", "ASRé”™è¯¯ï¼š" + e.error);
        };
    
        recognition.onend = () => {
          // å¦‚æœç”¨æˆ·æ²¡ç‚¹åœæ­¢ï¼Œè‡ªåŠ¨ç»­å¬ï¼ˆé¿å…è¯†åˆ«è‡ªåŠ¨åœï¼‰
          if (listening) {
            try { recognition.start(); } catch {}
          } else {
            setASRStatus("å·²åœæ­¢");
          }
        };
      }
    
      if (!listening) {
        listening = true;
        setASRStatus("ç›‘å¬ä¸­â€¦");
        document.getElementById("voiceBtn").textContent = "â¹ï¸ åœæ­¢è¯­éŸ³å¯¹è¯";
        if (agent.state === State.IDLE) {
          const greet = "æˆ‘æ˜¯AIå¨æˆ¿åŠ©æ‰‹ã€‚æ‚¨å¯ä»¥è¯´ï¼šåšé¥­ã€æ¨èèœã€ä»Šå¤©åƒä»€ä¹ˆã€‚";
          logChat("AI", greet); speakCN(greet);
        }
        try { recognition.start(); } catch {}
      } else {
        listening = false;
        document.getElementById("voiceBtn").textContent = "ğŸ™ï¸ å¼€å§‹è¯­éŸ³å¯¹è¯";
        try { recognition.stop(); } catch {}
        setASRStatus("å·²åœæ­¢");
      }
    });
    
    
    
    
        
      </script>
    </body>
    </html>
